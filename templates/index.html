<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Itinéraire vélo — v0.6 (OSRM bike)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- Leaflet Routing Machine -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.min.js"></script>

  <!-- Chart.js (profil d'altitude auto) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --profile-height: 200px;
      --topbar-height: 56px;
      --sidepanel-width: 0px; /* 0 par défaut (panneau fermé) */
    }
    html, body { height: 100%; margin: 0; }
    #map { position: absolute; inset: var(--topbar-height) var(--sidepanel-width) var(--profile-height) 0; transition: inset .25s ease; }

    /* Top bar */
    .topbar {
      position: fixed; top: 0; left: 0; right: 0; height: var(--topbar-height);
      display: grid;
      grid-template-columns: 1fr 1fr auto auto auto auto auto auto 1fr;
      gap: 8px; align-items: center; padding: 8px 10px; background: #fff; z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,.08); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .topbar input {
      height: 38px; padding: 0 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;
    }
    .topbar button {
      height: 38px; padding: 0 12px; border: 1px solid #ddd; background: #fff; border-radius: 8px; cursor: pointer; font-size: 14px;
    }
    .topbar button.primary { background: #0ea5e9; color: white; border-color: #0ea5e9; }
    .hint { text-align: right; font-size: 12px; color: #666; padding-right: 4px; }

    /* Profil altitude (bas) */
    .bottombox {
      position: fixed; left: 0; right: var(--sidepanel-width); bottom: 0; height: var(--profile-height);
      background: #fff; z-index: 1000; box-shadow: 0 -2px 10px rgba(0,0,0,.08);
      padding: 10px; padding-top: 40px; transition: height .25s ease, right .25s ease; overflow: hidden;
    }
    .bottombox.collapsed { height: 0px; }
    #elevCanvas { width: 100%; height: 100%; }
    .profile-toggle {
      position: absolute; top: 6px; right: 10px;
      background: #0ea5e9; color: white; border: none;
      padding: 6px 10px; border-radius: 6px; cursor: pointer;
      font-size: 13px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    /* Panneau d'itinéraire (droite) */
    .sidepanel {
      position: fixed; top: var(--topbar-height); right: 0; width: var(--sidepanel-width); bottom: var(--profile-height);
      background: #fff; z-index: 1100; box-shadow: -2px 0 10px rgba(0,0,0,.08);
      border-left: 1px solid #eee; overflow: hidden; transition: width .25s ease;
      display: grid; grid-template-rows: auto 1fr; /* header + contenu scroll */
    }
    .sidepanel .header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; border-bottom: 1px solid #eee; gap: 8px;
    }
    .sidepanel .header .title { font-weight: 600; }
    .sidepanel .header button {
      border: 1px solid #ddd; background: #fff; border-radius: 8px; padding: 6px 10px; cursor: pointer; font-size: 13px;
    }
    .sidepanel .content {
      overflow: auto; padding: 10px 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-size: 14px;
    }
    .summary { margin-bottom: 10px; }
    .summary b { font-weight: 700; }
    details.instructions summary {
      padding: 8px 10px; background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; user-select: none;
    }
    details.instructions .steps {
      margin-top: 10px; padding-left: 0; list-style: none;
    }
    .step { padding: 6px 8px; border-bottom: 1px dashed #eee; }
    .step small { color: #555; }

    /* Cacher le panneau LRM d’origine */
    .leaflet-routing-container { display: none !important; }
    .leaflet-top.leaflet-left .leaflet-control-zoom {
      margin-top: 20px; /* décale vers le bas (ajuste la valeur si besoin) */
    }

    @media (max-width: 1100px){
      .topbar { grid-template-columns: 1fr 1fr auto auto auto auto auto 1fr; grid-auto-rows: 40px; height:auto; }
      .hint { display: none; }
    }

    /* Autocomplete */
    .ac-wrap { position: relative; }
    .ac-list {
      position: absolute; top: 42px; left: 0; right: 0; z-index: 1200;
      background: #fff; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0 8px 24px rgba(0,0,0,.12);
      max-height: 240px; overflow: auto; padding: 6px 0;
    }
    .ac-item {
      padding: 8px 10px; cursor: pointer; font-size: 14px; line-height: 1.2;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .ac-item:hover, .ac-item.active { background: #f0f9ff; }

    .map-btn {
      position: absolute;
      top: calc(var(--topbar-height) + 20px);
      right: calc(var(--sidepanel-width) + 10px); /* décale selon panneau */
      z-index: 1200;
      background: #fff;
      border: 1px solid #d1d5db;
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,.15);
      transition: right 0.25s ease; /* anim du déplacement */
    }

    /* Bouton flottant (gauche, sous la topbar) */
    .map-btn-adv{
      position: absolute;
      top: calc(var(--topbar-height) + 90px);
      left: 10px;
      z-index: 1200;
      background: #fff;
      border: 1px solid #d1d5db;
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 18px;
      line-height: 1;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,.15);
    }

    /* Panneau Avancé */
    .adv-panel{
      position: fixed;
      top: calc(var(--topbar-height) + 10px);
      left: 10px;
      width: 280px;
      max-height: calc(100vh - var(--topbar-height) - 20px);
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      box-shadow: 0 12px 24px rgba(0,0,0,.15);
      z-index: 1300;
      overflow: hidden;
      transition: transform .22s ease, opacity .22s ease;
    }
    .adv-panel.collapsed{
      transform: translateY(-10px);
      opacity: 0;
      pointer-events: none;
    }
    .adv-header{
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; border-bottom: 1px solid #f1f5f9;
    }
    .adv-close{
      background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; cursor: pointer; padding: 4px 8px;
    }
    .adv-body{
      padding: 10px 12px; display: grid; gap: 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-size: 14px;
    }
    .adv-body label{ display: grid; gap: 4px; }
    .adv-body input[type="number"]{
      height: 34px; padding: 0 8px; border: 1px solid #e5e7eb; border-radius: 8px;
    }
    .adv-actions{ display: flex; justify-content: flex-end; margin-top: 4px; }
    .adv-reset{
      background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 6px 10px; cursor: pointer;
    }

    .wx-ctrl{
      position: absolute;
      top: calc(var(--topbar-height) + 130px);
      left: 10px; /* côté gauche pour ne pas gêner le bouton ≡ à droite */
      z-index: 1200;
      width: 220px;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,.12);
      padding: 8px 10px;
      display: grid; gap: 6px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 13px;
    }
    .wx-row{ display: flex; align-items: center; gap: 8px; }
    #wxSlider{ width: 100%; }
    .wx-time{ color:#475569; text-align:right; min-height: 18px; }


  </style>
</head>
<body>
  <div class="topbar">
    <div class="ac-wrap"><input id="startInput" placeholder="Départ (adresse ou lieu)" autocomplete="off" /></div>
    <div class="ac-wrap"><input id="endInput"   placeholder="Arrivée (adresse ou lieu)" autocomplete="off" /></div>
    <button id="btnGo" class="primary">Tracer</button>
    <button id="btnSwap" title="Inverser A↔B">Inverser</button>
    <button id="btnClear">Effacer</button>
    <button id="btnExport">Exporter GPX</button>

    <input id="avgSpeed" type="number" min="1" max="80" step="0.5" value="25" title="Vitesse moyenne (km/h)" />
    <span id="stats" style="font-size:13px;color:#444;">—</span>

    <div class="hint">Astuce : Shift+clic sur la carte pour ajouter une étape</div>
  </div>

  <div id="map"></div>
  <button id="btnMapToggle" class="map-btn" title="Afficher le panneau itinéraire">≡</button>

  <!-- Contrôles météo (radar pluie) -->
  <div id="wxCtrl" class="wx-ctrl">
    <label class="wx-row">
      <input type="checkbox" id="wxToggle" />
      <span>Pluie (prévision)</span>
    </label>
    <input type="range" id="wxSlider" min="0" max="0" value="0" disabled />
    <div class="wx-time" id="wxTime">—</div>
  </div>


    <!-- Bouton flottant pour le panneau Avancé -->
  <button id="btnAdv" class="map-btn-adv" title="Paramètres avancés">⚙︎</button>

  <!-- Panneau Avancé (rétracté par défaut) -->
  <div id="advPanel" class="adv-panel collapsed" aria-hidden="true">
    <div class="adv-header">
      <strong>Paramètres avancés</strong>
      <button id="btnAdvClose" class="adv-close" title="Fermer">×</button>
    </div>
    <div class="adv-body">
      <label>Penalité montée K_UP (%/point) 
        <input id="inpKUp" type="number" step="0.005" min="0" max="0.2" value="0.04">
      </label>

      <label>Bonus descente K_DOWN (%/point)
        <input id="inpKDown" type="number" step="0.005" min="0" max="0.2" value="0.015">
      </label>

      <label>Bonus descente max (facteur)
        <input id="inpBoostMax" type="number" step="0.05" min="1" max="2" value="1.3">
      </label>

      <label>Vitesse mini montée (facteur)
        <input id="inpVmin" type="number" step="0.05" min="0.1" max="1" value="0.25">
      </label>

      <label>(Profil) pente rouge à partir de (%)
        <input id="inpSlopeMax" type="number" step="1" min="6" max="20" value="10">
      </label>

      <div class="adv-actions">
        <button id="btnAdvReset" class="adv-reset">Réinitialiser</button>
      </div>
    </div>
  </div>


  <!-- Panneau d’itinéraire (droite) -->
  <aside id="sidepanel" class="sidepanel">
    <div class="header">
      <div class="title">Itinéraire</div>
    </div>
    <div class="content">
      <div class="summary" id="routeSummary"><b>—</b></div>
      <details class="instructions" id="detailsBox" open>
        <summary>Indications détaillées</summary>
        <ul class="steps" id="stepsList"></ul>
      </details>
    </div>
  </aside>

  <!-- Panneau profil altitude (bas) -->
  <div id="bottom" class="bottombox collapsed">
    <button id="btnToggleProfile" class="profile-toggle">Profil ⌃</button>
    <canvas id="elevCanvas"></canvas>
  </div>

  <script>
    // ====== Constantes profil/pente & panneau latéral
    let SLOPE_MAX = 10;           // % : >=10% = rouge vif
    const SIDE_OPEN_WIDTH = 340;    // px : largeur du panneau itinéraire ouvert

    // Modèle de vitesse adaptative (ajuste si besoin)
    let K_UP = 0.04;      // -4% de vitesse par point de % en montée
    let K_DOWN = 0.015;   // +1.5% de vitesse par point de % en descente
    let BOOST_MAX = 1.30; // bonus max en descente (130% de la vitesse de base)
    let VMIN_FACTOR = 0.25; // vitesse mini en montée (25% de la vitesse de base)


    // ====== Carte
    const map = L.map('map').setView([48.8566, 2.3522], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    // ====== OSRM routed-bike (vélo)
    const routing = L.Routing.control({
      router: L.Routing.osrmv1({
        serviceUrl: 'https://routing.openstreetmap.de/routed-bike/route/v1',
        profile: 'cycling'
      }),
      routeWhileDragging: true,
      addWaypoints: false,
      draggableWaypoints: true,
      showAlternatives: false,
      altLineOptions: { styles: [{opacity: 0.7, weight: 6}, {opacity: 0.9, weight: 3, dashArray: '7,12'}] },
      language: 'fr',

      createMarker: function(i, wp, nWps) {
        // i = index du waypoint, wp = waypoint, nWps = nombre total
        const startIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
        });
        const endIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
        });
        const viaIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41]
        });

        if (i === 0) return L.marker(wp.latLng, {icon: startIcon, draggable: true});
        if (i === nWps - 1) return L.marker(wp.latLng, {icon: endIcon, draggable: true});
        return L.marker(wp.latLng, {icon: viaIcon, draggable: true});
      }
    }).addTo(map);


    // ====== Géocodage + Autocomplete (Photon -> Nominatim fallback)
    async function geocodePhoton(q){
      const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(q)}&lang=fr&limit=1`;
      const r = await fetch(url);
      if (!r.ok) throw new Error('Photon indisponible');
      const j = await r.json();
      if (!j.features?.length) throw new Error('Aucun résultat');
      const [lon, lat] = j.features[0].geometry.coordinates;
      return L.latLng(lat, lon);
    }
    async function geocodeNominatim(q){
      const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=1&q=${encodeURIComponent(q)}`;
      const r = await fetch(url, { headers: { 'Accept-Language': 'fr' }});
      if (!r.ok) throw new Error('Nominatim indisponible');
      const j = await r.json();
      if (!j.length) throw new Error('Aucun résultat');
      return L.latLng(parseFloat(j[0].lat), parseFloat(j[0].lon));
    }
    async function geocode(q){ try { return await geocodePhoton(q); } catch(_) { return await geocodeNominatim(q); } }

    async function autocompletePhoton(q){
      const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(q)}&lang=fr&limit=6`;
      const r = await fetch(url);
      if (!r.ok) return [];
      const j = await r.json();
      return (j.features || []).map(f => ({
        label: f.properties.label || f.properties.name || f.properties.street || f.properties.city,
        lat: f.geometry.coordinates[1],
        lon: f.geometry.coordinates[0],
      })).filter(x => x.label);
    }
    function attachAutocomplete(inputEl, onPick){
      let box = null, items = [], active = -1, lastQ = '';
      const wrap = inputEl.parentElement;
      function close(){ active=-1; items=[]; if (box){ box.remove(); box=null; } }
      function render(){
        if (box) box.remove();
        if (!items.length) return;
        box = document.createElement('div'); box.className = 'ac-list';
        items.forEach((it, idx) => {
          const div = document.createElement('div'); div.className = 'ac-item' + (idx===active?' active':'');
          div.textContent = it.label;
          div.onclick = () => { inputEl.value = it.label; close(); onPick(L.latLng(it.lat, it.lon)); };
          box.appendChild(div);
        });
        wrap.appendChild(box);
      }
      async function update(){
        const q = inputEl.value.trim();
        if (q.length < 3 || q === lastQ){ close(); return; }
        lastQ = q;
        items = await autocompletePhoton(q);
        active = -1; render();
      }
      const debounced = ((fn, ms) => { let t; return (...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a),ms);} })(update, 200);

      inputEl.addEventListener('input', debounced);
      inputEl.addEventListener('focus', update);
      inputEl.addEventListener('blur', () => setTimeout(close, 150));
      inputEl.addEventListener('keydown', (e) => {
        if (!items.length) return;
        if (e.key === 'ArrowDown'){ active = Math.min(active+1, items.length-1); render(); e.preventDefault(); }
        else if (e.key === 'ArrowUp'){ active = Math.max(active-1, 0); render(); e.preventDefault(); }
        else if (e.key === 'Enter'){ 
          if (active>=0){ const it = items[active]; inputEl.value = it.label; close(); onPick(L.latLng(it.lat, it.lon)); e.preventDefault(); }
        } else if (e.key === 'Escape'){ close(); }
      });
    }

    // ====== État & utils
    let currentCoords = [];     // [[lat, lon], ...]
    let lastProfileCoords = []; // [[lat,lon], ...] downsamplés
    let lastProfileElev = [];   // [ele, ...] correspondants
    let elevChart = null;
    let lastDistanceKm = 0;

    const toRad = x => x * Math.PI/180;
    function haversine(a, b){
      const R = 6371000;
      const dLat = toRad(b[0]-a[0]), dLon = toRad(b[1]-a[1]);
      const la1 = toRad(a[0]), la2 = toRad(b[0]);
      const s = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(s));
    }
    function latlngDist(a,b){ return haversine([a.lat,a.lng],[b.lat,b.lng]); }
    function downsampleStep(coords, stepMeters=100){
      if (coords.length <= 2) return coords.slice();
      const out = [coords[0]];
      let acc = 0;
      for (let i=1;i<coords.length;i++){
        acc += haversine(coords[i-1], coords[i]);
        if (acc >= stepMeters){ out.push(coords[i]); acc = 0; }
      }
      const last = coords[coords.length-1];
      if (out[out.length-1][0] !== last[0] || out[out.length-1][1] !== last[1]) out.push(last);
      return out;
    }
    function densify(coords, stepMeters=30){
      const out = [];
      function interp(p, q, t){ return [p[0]+t*(q[0]-p[0]), p[1]+t*(q[1]-p[1])]; }
      for (let i=0;i<coords.length-1;i++){
        const a = coords[i], b = coords[i+1];
        const segLen = haversine(a,b);
        const n = Math.max(1, Math.floor(segLen/stepMeters));
        for (let k=0;k<n;k++){ out.push(interp(a,b,k/n)); }
      }
      out.push(coords[coords.length-1]);
      return out;
    }
    function debounce(fn, wait){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); }; }

    // ====== Altitudes (fallback Open-Elevation)
    async function fetchElevations(latlngs){
      const chunkSize = 80, elev = [];
      for (let i=0;i<latlngs.length;i+=chunkSize){
        const chunk = latlngs.slice(i, i+chunkSize);
        const locations = chunk.map(p => p[0].toFixed(6)+','+p[1].toFixed(6)).join('|');
        const url = `https://api.open-elevation.com/api/v1/lookup?locations=${locations}`;
        const r = await fetch(url);
        if (!r.ok) throw new Error('Open-Elevation indisponible');
        const j = await r.json();
        elev.push(...j.results.map(o => o.elevation));
        await new Promise(res => setTimeout(res, 120));
      }
      return elev;
    }

    // ====== Courbe altitude + remplissage couleur (montées uniquement)
    function drawElevationProfile(distKm, elevations){
      // pente locale (%)
      const slopes = [0];
      for (let i = 1; i < elevations.length; i++){
        const dkm = distKm[i] - distKm[i-1];
        const dz  = elevations[i] - elevations[i-1];
        const d_m = Math.max(dkm * 1000, 1e-6);
        slopes.push(100 * dz / d_m); // % (positive = montée)
      }

      function slopeColor(p){
        if (p <= 0) return 'rgba(34,197,94,0.25)'; // descente/plat : vert clair
        const s = Math.min(p, SLOPE_MAX);
        const t = s / SLOPE_MAX;
        const c1 = [34,197,94];   // vert
        const c2 = [245,158,11];  // orange
        const c3 = [239,68,68];   // rouge
        let r,g,b;
        if (t <= 0.5){
          const u = t/0.5;
          r = Math.round(c1[0] + u*(c2[0]-c1[0]));
          g = Math.round(c1[1] + u*(c2[1]-c1[1]));
          b = Math.round(c1[2] + u*(c2[2]-c1[2]));
        } else {
          const u = (t-0.5)/0.5;
          r = Math.round(c2[0] + u*(c3[0]-c2[0]));
          g = Math.round(c2[1] + u*(c3[1]-c2[1]));
          b = Math.round(c2[2] + u*(c3[2]-c2[2]));
        }
        return `rgba(${r},${g},${b},0.35)`;
      }

      const ctx = document.getElementById('elevCanvas').getContext('2d');
      if (elevChart) elevChart.destroy();

      const areaDataset = {
        label: 'Pente',
        data: elevations,
        tension: 0.2,
        pointRadius: 0,
        borderWidth: 0,
        fill: true,
        segment: {
          backgroundColor: (segCtx) => {
            const i = segCtx.p0DataIndex;
            return slopeColor(slopes[i+1] || 0);
          },
          borderColor: 'rgba(0,0,0,0)'
        }
      };
      const lineDataset = {
        label: 'Altitude (m)',
        data: elevations,
        tension: 0.2,
        pointRadius: 0,
        borderWidth: 2,
        borderColor: '#334155',
        fill: false
      };

      elevChart = new Chart(ctx, {
        type: 'line',
        data: { labels: distKm.map(d => d.toFixed(2)), datasets: [areaDataset, lineDataset] },
        options: {
          maintainAspectRatio: false,
          scales: {
            x: { title: { display: true, text: 'Distance (km)' }, ticks: { maxTicksLimit: 10 } },
            y: { title: { display: true, text: 'Altitude (m)' } }
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                afterLabel: (tt) => {
                  const i = tt.dataIndex;
                  const s = slopes[i] || 0;
                  return `Pente: ${s.toFixed(1)} %`;
                }
              }
            }
          },
          elements: { line: { capBezierPoints: true } }
        }
      });
    }

    // ====== Profil automatique (debounce)
    async function updateProfile(){
      if (!currentCoords || currentCoords.length < 2) return;
      try {
        const profileCoords = downsampleStep(currentCoords, 100);
        const elevations = await fetchElevations(profileCoords);
        lastProfileCoords = profileCoords;
        lastProfileElev = elevations;
        updateStatsFromSpeed(); // la durée dépend maintenant du profil -> mets à jour
        const dist = [0];
        for (let i=1;i<profileCoords.length;i++){
          dist.push(dist[i-1] + haversine(profileCoords[i-1], profileCoords[i])/1000);
        }
        drawElevationProfile(dist, elevations);
      } catch (err) { console.warn('Profil alt échoué:', err); }
    }
    const scheduleProfileUpdate = debounce(updateProfile, 800);

    // ====== Distance/durée avec vitesse moyenne
    function formatDuration(sec){
      sec = Math.max(0, Math.round(sec));
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      if (h > 0) return `${h}h${String(m).padStart(2,'0')}`;
      return `${m} min`;
    }

    function estimateTimeAdaptiveSeconds(profileCoords, elevations, vFlatKmh){
      if (!profileCoords || profileCoords.length < 2 || elevations.length !== profileCoords.length || !isFinite(vFlatKmh) || vFlatKmh <= 0){
        return 0;
      }
      let timeSec = 0;
      const vMin = Math.max(1, vFlatKmh * VMIN_FACTOR); // km/h

      for (let i=1; i<profileCoords.length; i++){
        const a = profileCoords[i-1], b = profileCoords[i];
        const d_m = haversine(a, b);               // mètres
        if (d_m <= 0) continue;
        const dz = elevations[i] - elevations[i-1];
        const slope = (dz / d_m) * 100;            // pente %

        // facteur de vitesse selon pente (montée/descente)
        let factor;
        if (slope >= 0){
          factor = Math.max(VMIN_FACTOR, 1 - K_UP * slope);  // pénalité en montée
        } else {
          factor = Math.min(BOOST_MAX, 1 + K_DOWN * (-slope)); // petit bonus en descente
        }

        const v_kmh = Math.max(vMin, vFlatKmh * factor);
        const v_ms  = v_kmh / 3.6;
        timeSec += d_m / v_ms;
      }
      return timeSec;
    }
    function getEstimatedTimeSeconds(vKmh){
      if (!isFinite(vKmh) || vKmh <= 0) return 0;
      if (lastProfileCoords.length >= 2 && lastProfileElev.length === lastProfileCoords.length){
        return estimateTimeAdaptiveSeconds(lastProfileCoords, lastProfileElev, vKmh);
      }
      // fallback si pas encore de profil
      return (lastDistanceKm / vKmh) * 3600;
    }

    function polylineDistanceKm(coords){
      if (!coords || coords.length < 2) return 0;
      let d = 0;
      for (let i=1;i<coords.length;i++){ d += haversine(coords[i-1], coords[i]); }
      return d / 1000;
    }
    const $speed = document.getElementById('avgSpeed');
    const $stats = document.getElementById('stats');
    function updateStatsFromSpeed(){
      const v = parseFloat($speed.value); // km/h
      if (!isFinite(v) || v <= 0){
        $stats.textContent = '—';
        return;
      }

      // Si on a un profil (coords + élévations), calcule une durée adaptative
      const timeSec = getEstimatedTimeSeconds(v);
      $stats.textContent = `${lastDistanceKm.toFixed(1)} km · ${formatDuration(timeSec)}`;
      updateSideSummary(); // <-- garde !
    }

    $speed.addEventListener('input', updateStatsFromSpeed);
    $speed.addEventListener('change', updateStatsFromSpeed);



    // ====== Panneau d’itinéraire (droite) : toggle + contenu
    const sidepanel = document.getElementById('sidepanel');
    const stepsList = document.getElementById('stepsList');
    const routeSummary = document.getElementById('routeSummary');
    const detailsBox = document.getElementById('detailsBox');
    let sideOpen = false;
    const btnMapToggle = document.getElementById('btnMapToggle');

    function setSideWidth(px){
      document.documentElement.style.setProperty('--sidepanel-width', px + 'px');
    }
    function applySide(){
      setSideWidth(sideOpen ? SIDE_OPEN_WIDTH : 0);
      document.documentElement.style.setProperty('--sidepanel-width', sideOpen ? SIDE_OPEN_WIDTH + 'px' : '0px');
      // MAJ du bouton flottant
      if (btnMapToggle) {
        btnMapToggle.textContent = sideOpen ? '×' : '≡';
        btnMapToggle.title = sideOpen ? 'Masquer le panneau itinéraire' : 'Afficher le panneau itinéraire';
      }
      setTimeout(() => { map.invalidateSize(); if (elevChart) elevChart.resize(); }, 260);
    }


    function updateSideSummary(){
      const startLabel = document.getElementById('startInput').value || 'Départ';
      const endLabel   = document.getElementById('endInput').value   || 'Arrivée';
      const v = parseFloat($speed.value);
      const timeSec = getEstimatedTimeSeconds(v);

      routeSummary.innerHTML =
        `<b>${startLabel} → ${endLabel}</b><br>${lastDistanceKm.toFixed(1)} km · ${formatDuration(timeSec)}`;
    }


    function fillStepsFromRoute(route){
      // Vide
      stepsList.innerHTML = '';
      // e.routes[0].instructions (LRM) quand steps=true
      const instr = route.instructions || [];
      instr.forEach((it, idx) => {
        const li = document.createElement('li'); li.className = 'step';
        const dist = (it.distance != null) ? ` — <small>${(it.distance/1000).toFixed(2)} km</small>` : '';
        li.innerHTML = `${idx+1}. ${it.text}${dist}`;
        stepsList.appendChild(li);
      });
    }

    // ====== Événements de routage
    routing.on('routesfound', (e) => {
      const route = e.routes[0];
      currentCoords = route.coordinates.map(c => [c.lat, c.lng]);

      if (route.summary && typeof route.summary.totalDistance === 'number') {
        lastDistanceKm = route.summary.totalDistance / 1000.0;
      } else {
        lastDistanceKm = polylineDistanceKm(currentCoords);
      }

      // Panneau droit : résumé + étapes
      updateStatsFromSpeed();
      updateSideSummary();
      fillStepsFromRoute(route);

      scheduleProfileUpdate();
    });
    routing.on('routingerror', (e) => {
      console.error('Erreur OSRM:', e);
      alert("Erreur de calcul d'itinéraire. Réessaie ou modifie les points.");
    });

    function setAB(aLatLng, bLatLng){
      routing.setWaypoints([aLatLng, bLatLng]);
      map.fitBounds(L.latLngBounds([aLatLng, bLatLng]).pad(0.2));
    }

    // ====== Inputs + Autocomplete + actions
    const $start = document.getElementById('startInput');
    const $end   = document.getElementById('endInput');

    async function routeFromInputs(){
      try {
        const [A, B] = await Promise.all([geocode($start.value), geocode($end.value)]);
        setAB(A, B);
        // ouvre automatiquement le panneau itinéraire si fermé
        if (!sideOpen) { sideOpen = true; applySide(); }
      } catch (err) { alert("Recherche d'adresse impossible : " + err.message); }
    }
    document.getElementById('btnGo').addEventListener('click', routeFromInputs);
    [$start, $end].forEach(inp => inp.addEventListener('keydown', (e) => { if (e.key === 'Enter') routeFromInputs(); }));

    function attachAutocomplete(inputEl, onPick){
      let box = null, items = [], active = -1, lastQ = '';
      const wrap = inputEl.parentElement;
      function close(){ active=-1; items=[]; if (box){ box.remove(); box=null; } }
      function render(){
        if (box) box.remove();
        if (!items.length) return;
        box = document.createElement('div'); box.className = 'ac-list';
        items.forEach((it, idx) => {
          const div = document.createElement('div'); div.className = 'ac-item' + (idx===active?' active':'');
          div.textContent = it.label;
          div.onclick = () => { inputEl.value = it.label; close(); onPick(L.latLng(it.lat, it.lon)); };
          box.appendChild(div);
        });
        wrap.appendChild(box);
      }
      async function update(){
        const q = inputEl.value.trim();
        if (q.length < 3 || q === lastQ){ close(); return; }
        lastQ = q;
        // appelle l’API Photon pour suggestions
        const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(q)}&lang=fr&limit=6`;
        const r = await fetch(url);
        const j = r.ok ? await r.json() : {features:[]};
        items = (j.features || []).map(f => ({
          label: f.properties.label || f.properties.name || f.properties.street || f.properties.city,
          lat: f.geometry.coordinates[1],
          lon: f.geometry.coordinates[0],
        })).filter(x => x.label);
        active = -1; render();
      }
      const debounced = ((fn, ms) => { let t; return (...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a),ms);} })(update, 200);

      inputEl.addEventListener('input', debounced);
      inputEl.addEventListener('focus', update);
      inputEl.addEventListener('blur', () => setTimeout(close, 150));
      inputEl.addEventListener('keydown', (e) => {
        if (!items.length) return;
        if (e.key === 'ArrowDown'){ active = Math.min(active+1, items.length-1); render(); e.preventDefault(); }
        else if (e.key === 'ArrowUp'){ active = Math.max(active-1, 0); render(); e.preventDefault(); }
        else if (e.key === 'Enter'){ 
          if (active>=0){ const it = items[active]; inputEl.value = it.label; close(); onPick(L.latLng(it.lat, it.lon)); e.preventDefault(); }
        } else if (e.key === 'Escape'){ close(); }
      });
    }

    attachAutocomplete($start, (latlng) => {
      const wps = routing.getWaypoints();
      if (wps[1]?.latLng) setAB(latlng, wps[1].latLng);
      else routing.spliceWaypoints(0, 1, latlng);
      if (!sideOpen) { sideOpen = true; applySide(); }
    });
    attachAutocomplete($end, (latlng) => {
      const wps = routing.getWaypoints();
      if (wps[0]?.latLng) setAB(wps[0].latLng, latlng);
      else routing.spliceWaypoints(1, 1, latlng);
      if (!sideOpen) { sideOpen = true; applySide(); }
    });

    document.getElementById('btnSwap').addEventListener('click', () => {
      const tmp = $start.value; $start.value = $end.value; $end.value = tmp;
      const wps = routing.getWaypoints();
      if (wps[0].latLng && wps[1].latLng) setAB(wps[1].latLng, wps[0].latLng);
    });

    document.getElementById('btnClear').addEventListener('click', () => {
      routing.setWaypoints([]);
      currentCoords = [];
      lastDistanceKm = 0;
      updateStatsFromSpeed();
      stepsList.innerHTML = '';
      routeSummary.innerHTML = '<b>—</b>';
    });

    // Clics carte : 1er = A, 2e = B, ensuite Shift+clic pour via-point
    map.on('click', (e) => {
      const wps = routing.getWaypoints();
      const defined = wps.filter(w => w.latLng);
      if (defined.length === 0){
        routing.spliceWaypoints(0, 1, e.latlng);
      } else if (defined.length === 1){
        routing.spliceWaypoints(1, 1, e.latlng);
      } else {
        if (!e.originalEvent.shiftKey) return;
        const tooClose = wps.some(w => w.latLng && latlngDist(w.latLng, e.latlng) < 15);
        if (tooClose) return;
        routing.spliceWaypoints(wps.length, 0, e.latlng);
      }
      if (!sideOpen) { sideOpen = true; applySide(); }
    });

    // ====== Export GPX (avec <ele> via Open-Elevation)
    async function exportGPX(){
      if (!currentCoords || currentCoords.length < 2){ alert("Pas de trajet à exporter."); return; }
      const gpxCoords = densify(currentCoords, 30);
      let elev;
      try { elev = await fetchElevations(gpxCoords); }
      catch (err){ alert("Altitude indisponible pour le GPX : "+err.message); return; }
      const now = new Date().toISOString();
      const header =
`<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="velo-routeur-v0.6"
  xmlns="http://www.topografix.com/GPX/1/1"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.topografix.com/GPX/1/1
  http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata><time>${now}</time></metadata>
  <trk><name>itineraire-velo</name><trkseg>
`;
      const points = gpxCoords.map(([lat, lon], i) =>
        `    <trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}"><ele>${(elev[i] ?? 0).toFixed(1)}</ele></trkpt>`
      ).join("\n");
      const footer = `
  </trkseg></trk>
</gpx>`;
      const gpx = header + points + footer;
      const blob = new Blob([gpx], {type: 'application/gpx+xml'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'itineraire-velo.gpx';
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    }
    document.getElementById('btnExport').addEventListener('click', exportGPX);
    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's'){ e.preventDefault(); exportGPX(); }
    });

    // ====== Toggle profil (rétracté par défaut) + resize carte/graph
    const bottomBox = document.getElementById('bottom');
    const btnToggle = document.getElementById('btnToggleProfile');
    let collapsed = true; // rétracté par défaut
    function applyLayout(){
      bottomBox.classList.toggle('collapsed', collapsed);
      document.getElementById('map').style.inset = collapsed
        ? `var(--topbar-height) var(--sidepanel-width) 0 0`
        : `var(--topbar-height) var(--sidepanel-width) var(--profile-height) 0`;
      btnToggle.textContent = collapsed ? 'Profil ⌃' : 'Profil ⌄';
      setTimeout(() => { map.invalidateSize(); if (elevChart) elevChart.resize(); }, 260);
    }
    btnToggle.addEventListener('click', () => { collapsed = !collapsed; applyLayout(); });
    bottomBox.addEventListener('dblclick', () => { collapsed = !collapsed; applyLayout(); });
    btnMapToggle.addEventListener('click', () => { sideOpen = !sideOpen; applySide(); });


    // applique l'état initial au chargement
    applyLayout();
    // applique l'état latéral (fermé par défaut)
    applySide();

        // ----- Panneau Avancé (rétracté par défaut)
    const advPanel  = document.getElementById('advPanel');
    const btnAdv    = document.getElementById('btnAdv');
    const btnAdvClose = document.getElementById('btnAdvClose');

    const inpKUp      = document.getElementById('inpKUp');
    const inpKDown    = document.getElementById('inpKDown');
    const inpBoostMax = document.getElementById('inpBoostMax');
    const inpVmin     = document.getElementById('inpVmin');
    const inpSlopeMax = document.getElementById('inpSlopeMax');
    const btnAdvReset = document.getElementById('btnAdvReset');

    function advOpen(open){
      advPanel.classList.toggle('collapsed', !open);
      advPanel.setAttribute('aria-hidden', open ? 'false' : 'true');
    }
    btnAdv.addEventListener('click', () => advOpen(advPanel.classList.contains('collapsed')));
    btnAdvClose.addEventListener('click', () => advOpen(false));

    // Mise à jour des paramètres + recalcul temps/profil
    function applyAdvParams(){
      const kUp   = parseFloat(inpKUp.value);
      const kDown = parseFloat(inpKDown.value);
      const bMax  = parseFloat(inpBoostMax.value);
      const vMinF = parseFloat(inpVmin.value);
      const sMax  = parseFloat(inpSlopeMax.value);

      if (isFinite(kUp))   K_UP = Math.max(0, kUp);
      if (isFinite(kDown)) K_DOWN = Math.max(0, kDown);
      if (isFinite(bMax))  BOOST_MAX = Math.max(1, bMax);
      if (isFinite(vMinF)) VMIN_FACTOR = Math.min(1, Math.max(0.05, vMinF));
      if (isFinite(sMax))  SLOPE_MAX = Math.max(6, sMax);

      // Recalcule la durée avec le modèle adaptatif
      updateStatsFromSpeed();

      // Repeins le profil (couleurs dépendent de SLOPE_MAX)
      if (lastProfileCoords.length >= 2 && lastProfileElev.length === lastProfileCoords.length){
        const dist = [0];
        for (let i=1;i<lastProfileCoords.length;i++){
          dist.push(dist[i-1] + haversine(lastProfileCoords[i-1], lastProfileCoords[i])/1000);
        }
        drawElevationProfile(dist, lastProfileElev);
      }
    }

    // Appliquer à chaque changement
    [inpKUp, inpKDown, inpBoostMax, inpVmin, inpSlopeMax].forEach(el => {
      el.addEventListener('input', applyAdvParams);
      el.addEventListener('change', applyAdvParams);
    });

    // Reset valeurs par défaut
    btnAdvReset.addEventListener('click', () => {
      inpKUp.value = 0.04;
      inpKDown.value = 0.015;
      inpBoostMax.value = 1.3;
      inpVmin.value = 0.25;
      inpSlopeMax.value = 10;
      applyAdvParams();
    });

    // Optionnel : charger/enregistrer dans localStorage
    (function advInitFromStorage(){
      try{
        const s = JSON.parse(localStorage.getItem('advParams') || '{}');
        if (s.K_UP!=null)       inpKUp.value = s.K_UP;
        if (s.K_DOWN!=null)     inpKDown.value = s.K_DOWN;
        if (s.BOOST_MAX!=null)  inpBoostMax.value = s.BOOST_MAX;
        if (s.VMIN_FACTOR!=null)inpVmin.value = s.VMIN_FACTOR;
        if (s.SLOPE_MAX!=null)  inpSlopeMax.value = s.SLOPE_MAX;
      }catch{}
      applyAdvParams();
      // Sauvegarde à chaque modif
      [inpKUp, inpKDown, inpBoostMax, inpVmin, inpSlopeMax].forEach(el=>{
        el.addEventListener('change', ()=>{
          const s = {
            K_UP: parseFloat(inpKUp.value),
            K_DOWN: parseFloat(inpKDown.value),
            BOOST_MAX: parseFloat(inpBoostMax.value),
            VMIN_FACTOR: parseFloat(inpVmin.value),
            SLOPE_MAX: parseFloat(inpSlopeMax.value)
          };
          localStorage.setItem('advParams', JSON.stringify(s));
        });
      });
    })();

    // ====== Radar pluie (RainViewer) — prévision nowcast + slider temps
    const wxToggle = document.getElementById('wxToggle');
    const wxSlider = document.getElementById('wxSlider');
    const wxTime   = document.getElementById('wxTime');

    let rvFrames = [];           // frames disponibles (objets API RainViewer)
    let rvLayers = [];           // Leaflet TileLayers cacheés par index
    let rvIndex  = 0;            // index courant
    let rvLoaded = false;        // avons-nous chargé les frames ?

    function formatLocalTime(ts){ // ts en secondes
      const d = new Date(ts * 1000);
      // Affiche en heure locale courte (ex: 14:30)
      return d.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'});
    }

    async function loadRainViewer(){
      // API publique : frames passées & nowcast
      const url = 'https://api.rainviewer.com/public/weather-maps.json';
      const r = await fetch(url);
      if (!r.ok) throw new Error('RainViewer indisponible');
      const j = await r.json();

      // Combine passé et futur pour plus de frames
      let frames = [];
      if (j.radar && j.radar.past) frames = frames.concat(j.radar.past);
      if (j.radar && j.radar.nowcast) frames = frames.concat(j.radar.nowcast);

        
      rvFrames = frames;
      rvLayers = new Array(frames.length);
      rvIndex = frames.length ? frames.length - 1 : 0; // par défaut la plus récente
      wxSlider.min = 0;
      wxSlider.max = Math.max(0, frames.length - 1);
      wxSlider.value = rvIndex;
      wxSlider.disabled = frames.length === 0;
      wxTime.textContent = frames.length ? formatLocalTime(frames[rvIndex].time) : '—';
      rvLoaded = true;
    }

    function buildTileLayerFor(frame){
      // frame.path fourni par l’API. Exemple:
      // https://tilecache.rainviewer.com + frame.path + '/256/{z}/{x}/{y}/2/1_1.png'
      const url = `https://tilecache.rainviewer.com${frame.path}/256/{z}/{x}/{y}/2/1_1.png`;
      return L.tileLayer(url, {
        tileSize: 256,
        opacity: 0.6,
        zIndex: 400,
        attribution: '&copy; RainViewer'
      });
    }

    function showRainLayerAt(index){
      if (!rvFrames.length) return;

      // retire layer courant si différent
      for (let i=0;i<rvLayers.length;i++){
        if (rvLayers[i] && map.hasLayer(rvLayers[i])) map.removeLayer(rvLayers[i]);
      }

      rvIndex = Math.min(Math.max(index, 0), rvFrames.length - 1);
      if (!rvLayers[rvIndex]) rvLayers[rvIndex] = buildTileLayerFor(rvFrames[rvIndex]);
      rvLayers[rvIndex].addTo(map);
      wxTime.textContent = formatLocalTime(rvFrames[rvIndex].time);
    }

    wxToggle.addEventListener('change', async () => {
      if (wxToggle.checked){
        try{
          if (!rvLoaded) await loadRainViewer();
          showRainLayerAt(parseInt(wxSlider.value, 10) || rvIndex);
        } catch (e){
          console.warn(e);
          wxToggle.checked = false;
          alert("Impossible de charger la carte pluie pour le moment.");
        }
      } else {
        // retire tous les layers
        rvLayers.forEach(Lyr => { if (Lyr && map.hasLayer(Lyr)) map.removeLayer(Lyr); });
      }
    });

    wxSlider.addEventListener('input', () => {
      if (!rvLoaded || !wxToggle.checked) return;
      const idx = parseInt(wxSlider.value, 10) || 0;
      showRainLayerAt(idx);
    });


  </script>
</body>
</html>
